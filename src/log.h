#pragma once

//! \file log.h
//! \brief Message logger
//!
//! This is the facility used by udipe to report various events throughout the
//! library execution lifecycle.

#include <udipe/log.h>

#include <stdbool.h>
#include <threads.h>


/// \name Initialization
///@{

/// Message logger
///
/// This struct is created by setup_log() and contains all information needed
/// to perform logging using the primitives defined below.
///
/// For now, this is just a typedef of \ref udipe_log_config_t which encodes the
/// extra invariant that all default placeholders have been replaced with
/// corresponding default values.
typedef udipe_log_config_t logger_t;

/// Setup logging
///
/// This should be done as early as possible during the `udipe` initialization
/// process in order to reduce the amount of code that cannot perform logging.
logger_t setup_log(udipe_log_config_t callback);

///@}


/// \name with_logger() macro
///@{

/// Thread-local logger (implementation detail of with_logger())
///
/// This thread-local variable is used by with_logger() to locally enable a
/// lightweight log syntax.
extern thread_local const logger_t* udipe_thread_logger;

/// Restore old \ref udipe_thread_logger (implementation detail of with_logger())
///
/// This helper function enables with_logger() to clean up after itself through
/// the GNU `__cleanup__` attribute.
static inline void restore_thread_logger(const logger_t* old_logger) {
    udipe_thread_logger = old_logger;
}

/// Set up logging within a certain code scope
///
/// Call as `with_logger(&logger, { ... })` to be able to use log() and related
/// macros inside of the ... inner code scope.
///
/// This macro uses thread-local state, so it should be called at the start of
/// every public entry point and also early in the main function of every udipe
/// worker thread.
#define with_logger(logger_ptr, ...)  \
    do {  \
        const logger_t* udipe_old_logger  \
                        __attribute__((__cleanup__(restore_thread_logger)))  \
                        = udipe_thread_logger;  \
        udipe_thread_logger = (logger_ptr);  \
        if(true) __VA_ARGS__  \
    } while(false)

///@}


/// \name Logging API
///@{

/// Validate a logging call in `Debug` builds
#ifndef NDEBUG
    void validate_log(udipe_log_level_t level);
#else
    static inline void validate_log(udipe_log_level_t level) {}
#endif

/// Decide if a user log should be emitted
///
/// This function can only be called within the scope of with_logger().
///
/// This function is implicitly called by the logging macros, but you may want
/// to use it in situations where the logging message is not a static string but
/// something that is dynamically generated by something like sprintf().
///
/// Doing so ensures that the dynamic processing will not be performed when the
/// specified log level is disabled. Otherwise you are at the mercy of compiler
/// optimizations for this, which are notoriously unreliable in the presence of
/// memory allocation and system calls.
static inline bool log_enabled(udipe_log_level_t level) {
    validate_log(level);
    return level >= udipe_thread_logger->min_level;
}

/// Log a message if `level` is above configured logging threshold
///
/// This macro can only be used within the scope of with_logger(). It takes as
/// input a \link #udipe_log_level_t log level \endlink and the message to be
/// logged at this log level.
///
/// You should prefer using the log level specific macros error(), warning(),
/// info(), debug() and trace() over this one, outside of special circumstances
/// where you want to dynamically adjust the log level at runtime.
///
/// If generating a message requires expensive processing that should not be
/// performed when the target log level is disabled, use log_enabled() to test
/// ahead of time whether this log level is enabled.
#define log(level, message)  \
    do {  \
        const LogLevel udipe_level = (level);  \
        if (log_enabled(udipe_level)) {  \
            (udipe_thread_logger->callback)(udipe_thread_logger->context,  \
                                            udipe_level,  \
                                            "libudipe::" __func__,  \
                                            (message));  \
        }  \
    } while(false)

/// Log a \link #UDIPE_LOG_TRACE `TRACE` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define trace(message)  log(UDIPE_LOG_TRACE, (message))

/// Log a \link #UDIPE_LOG_DEBUG `DEBUG` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define debug(message)  log(UDIPE_LOG_DEBUG, (message))

/// Log an \link #UDIPE_LOG_INFO `INFO` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define info(message)  log(UDIPE_LOG_INFO, (message))

/// Log a \link #UDIPE_LOG_WARNING `WARNING` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define warning(message)  log(UDIPE_LOG_WARNING, (message))

/// Log an \link #UDIPE_LOG_ERROR `ERROR` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define error(message)  log(UDIPE_LOG_ERROR, (message))

///@}