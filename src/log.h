#pragma once

//! \file
//! \brief Message logger
//!
//! This code module implements the logging facility used by udipe to report
//! various events throughout the library execution lifecycle.

#include <udipe/log.h>

#include <stdbool.h>
#include <threads.h>


/// \name Logger set up
/// \{

/// Message logger
///
/// This struct is created by log_initialize() and contains all information
/// needed to perform logging using the primitives from `src/log.h`.
///
/// For now, this is just a typedef of \ref udipe_log_config_t which encodes the
/// extra invariant that all zero placeholders have been replaced with
/// corresponding default values.
typedef udipe_log_config_t logger_t;

/// Set up logging
///
/// This should be done as early as possible during the `libudipe`
/// initialization process in order to reduce the amount of code that cannot
/// perform logging.
///
/// \param config should be valid per \link #udipe_log_config_t the type
///        definition. \endlink
///
/// \return A logger that can be passed to with_logger() as long as the
///         surrounding \ref udipe_context_t has not been finalized.
logger_t log_initialize(udipe_log_config_t config);

///@}


/// \name Basic logging
/// \{

/// Decide if a user log should be emitted
///
/// This function can only be called within the scope of with_logger().
///
/// This function is implicitly called by the logging macros, but you may want
/// to use it manually in situations where the logging message is not a static
/// string but a string that is dynamically generated by something like
/// sprintf().
///
/// Doing so ensures that the dynamic processing will not be performed when the
/// specified log level is disabled. Otherwise you are at the mercy of compiler
/// optimizations for this, which are notoriously unreliable in the presence of
/// memory allocation and system calls.
static inline bool log_enabled(udipe_log_level_t level);

/// Log a message if `level` is above configured logging threshold
///
/// This macro can only be used within the scope of with_logger(). It takes as
/// input a \link #udipe_log_level_t log level \endlink and the message to be
/// logged at this log level (as a standard `NULL`-terminated `const char[]`).
///
/// You should prefer using the log level specific macros error(), warning(),
/// info(), debug() and trace() over this one, outside of special circumstances
/// where you want to dynamically adjust the log level at runtime.
///
/// If generating a message requires expensive processing that should not be
/// performed when the target log level is disabled, then you should use
/// log_enabled() to test ahead of time whether this log level is enabled. For
/// the common case where the expensive process is generation of a formatted
/// text, we directly provide logf() and log level specific cousins thereof.
///
/// See also warn_on_errno() for cases where you need to report a failure from
/// system calls and third-party C libraries.
#define log(level, message)  \
    do {  \
        const udipe_log_level_t udipe_level = (level);  \
        if (log_enabled(udipe_level)) {  \
            (udipe_thread_logger->callback)(udipe_thread_logger->context,  \
                                            udipe_level,  \
                                            __func__,  \
                                            (message));  \
        }  \
    } while(false)

/// Log a \link #UDIPE_LOG_TRACE `TRACE` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define trace(message)  log(UDIPE_LOG_TRACE, (message))

/// Log a \link #UDIPE_LOG_DEBUG `DEBUG` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define debug(message)  log(UDIPE_LOG_DEBUG, (message))

/// Log an \link #UDIPE_LOG_INFO `INFO` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define info(message)  log(UDIPE_LOG_INFO, (message))

/// Log a \link #UDIPE_LOG_WARNING `WARNING` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define warning(message)  log(UDIPE_LOG_WARNING, (message))

/// Log an \link #UDIPE_LOG_ERROR `ERROR` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define error(message)  log(UDIPE_LOG_ERROR, (message))

/// \}


/// \name Formatted logging
/// \{

/// Log a message with printf() formatting
///
/// This macro works a lot like log(), but instead of logging a pre-existing
/// string, it builds a string on the fly using a printf()-style format string
/// and formatting arguments.
///
/// The price to pay for these enhanced formating capabilities is extra runtime
/// overhead, so prefer the basic logging macros where all you need to log is a
/// static string.
///
/// All other comments from log() remain valid, including the need to call it
/// inside the scope of with_logger(). See also errorf(), warningf(), infof(),
/// debugf() and tracef() for level-specific formatted logging macros.
#define logf(level, format, ...)  \
    do {  \
        const udipe_log_level_t udipe_level = (level);  \
        if (log_enabled(udipe_level)) {  \
            logf_impl(udipe_level,  \
                      __func__,  \
                      (format),  \
                      __VA_ARGS__);  \
        }  \
    } while(false);

/// Log a \link #UDIPE_LOG_TRACE `TRACE` \endlink formatted message
///
/// Can only be used within the scope of with_logger(). See logf() for more info.
#define tracef(format, ...)  logf(UDIPE_LOG_TRACE, (format), __VA_ARGS__)

/// Log a \link #UDIPE_LOG_DEBUG `DEBUG` \endlink formatted message
///
/// Can only be used within the scope of with_logger(). See logf() for more info.
#define debugf(format, ...)  logf(UDIPE_LOG_DEBUG, (format), __VA_ARGS__)

/// Log an \link #UDIPE_LOG_INFO `INFO` \endlink formatted message
///
/// Can only be used within the scope of with_logger(). See logf() for more info.
#define infof(format, ...)  logf(UDIPE_LOG_INFO, (format), __VA_ARGS__)

/// Log a \link #UDIPE_LOG_WARNING `WARNING` \endlink formatted message
///
/// Can only be used within the scope of with_logger(). See logf() for more info.
#define warningf(format, ...)  logf(UDIPE_LOG_WARNING, (format), __VA_ARGS__)

/// Log an \link #UDIPE_LOG_ERROR `ERROR` \endlink formatted message
///
/// Can only be used within the scope of with_logger(). See logf() for more info.
#define errorf(format, ...)  logf(UDIPE_LOG_ERROR, (format), __VA_ARGS__)

/// \}


/// \name Expression logging
/// \{

/// Log an expression and its value at TRACE level, along with the code location.
///
/// This macro is only meant for debugging purpose and should not remain
/// around in production code.
//
// TODO: Make this work with a single log statement using the same tricks as
//       ensure_comparison().
#define trace_expr(expr)  \
    do {  \
        tracef("At %s:%u.\n"  \
               "Evaluating %s...",   \
               __FILE__, __LINE__, #expr);  \
        tracef(format_for(expr), expr);  \
    } while(false)

/// \}


/// \name Thread-local logger
/// \{

/// Set up logging within a certain code scope
///
/// Call as `with_logger(&logger, { ... })` to be able to use log() and related
/// macros inside of the ... inner code scope.
///
/// This macro must be called at the start of every public `libudipe` entry
/// point and early on inside the main function of every udipe worker thread.
///
/// \param logger_ptr must point to a `logger_t` that was previously initialized
///        by log_initialize(), and that is valid to use until the end of the
///        code scope delimited by the with_logger() macro.
#define with_logger(logger_ptr, ...)  \
    do {  \
        const logger_t* udipe_prev_logger  \
                        __attribute__((__cleanup__(restore_thread_logger)))  \
                        = udipe_thread_logger;  \
        udipe_thread_logger = (logger_ptr);  \
        trace("Start of a with_logger() scope.");  \
        do __VA_ARGS__ while(false);  \
    } while(false)

///@}


/// \name Implementation details
/// @{

/// Internal helper to validate logging call correctness in `Debug` builds
///
/// Does nothing in `Release` builds.
#ifndef NDEBUG
    void validate_log(udipe_log_level_t level);
#else
    static inline void validate_log(udipe_log_level_t level) {}
#endif

/// GNU attributes of logf_impl()
///
/// This allows GCC to validate correct usage of this printf()-style function.
/// Extracting it into a macro deduplicates definition/declaration and works
/// around a bug in the doxygen parser.
#define LOGF_IMPL_ATTRIBUTES __attribute__((format(printf, 3, 4)))

/// Implementation of logf()
///
/// This function is not meant to be used directly, it is an implementation
/// detail of the logf() macro.
LOGF_IMPL_ATTRIBUTES
void logf_impl(udipe_log_level_t level,
               const char* location,
               const char* format,
               ...);

/// Thread-local logger (implementation detail of with_logger())
///
/// This thread-local variable is used by with_logger() in order to locally
/// enable a lightweight log syntax. It should not be used by any code other
/// than the log() and with_logger() macro.
extern thread_local const logger_t* udipe_thread_logger;

/// Restore `udipe_thread_logger` (implementation detail of with_logger())
///
/// This helper function enables with_logger() to clean up after itself through
/// the GNU `__cleanup__` attribute.
static inline void restore_thread_logger(const logger_t** prev_logger) {
    trace("End of a with_logger() scope.");
    udipe_thread_logger = *prev_logger;
}

/// @}


// Implementation of log_enabled (see docs above)
static inline bool log_enabled(udipe_log_level_t level) {
    validate_log(level);
    return level >= udipe_thread_logger->min_level;
}
