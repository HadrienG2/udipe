#pragma once

//! \file
//! \brief Message logger
//!
//! This code module implements the logging facility used by udipe to report
//! various events throughout the library execution lifecycle.

#include <udipe/log.h>

#include <stdbool.h>
#include <threads.h>


/// \name Initialization
///@{

/// Message logger
///
/// This struct is created by log_initialize() and contains all information
/// needed to perform logging using the primitives from `src/log.h`.
///
/// For now, this is just a typedef of \ref udipe_log_config_t which encodes the
/// extra invariant that all zero placeholders have been replaced with
/// corresponding default values.
typedef udipe_log_config_t logger_t;

/// Set up logging
///
/// This should be done as early as possible during the `libudipe`
/// initialization process in order to reduce the amount of code that cannot
/// perform logging.
///
/// \param config should be valid per \link #udipe_log_config_t the type
///        definition. \endlink
///
/// \return A logger that can be passed to with_logger() as long as the
///         surrounding \ref udipe_context_t has not been finalized.
logger_t log_initialize(udipe_log_config_t config);

///@}


/// \name Logging macros
///@{

/// Decide if a user log should be emitted
///
/// This function can only be called within the scope of with_logger().
///
/// This function is implicitly called by the logging macros, but you may want
/// to use it manually in situations where the logging message is not a static
/// string but a string that is dynamically generated by something like
/// sprintf().
///
/// Doing so ensures that the dynamic processing will not be performed when the
/// specified log level is disabled. Otherwise you are at the mercy of compiler
/// optimizations for this, which are notoriously unreliable in the presence of
/// memory allocation and system calls.
static inline bool log_enabled(udipe_log_level_t level);

/// Log a message if `level` is above configured logging threshold
///
/// This macro can only be used within the scope of with_logger(). It takes as
/// input a \link #udipe_log_level_t log level \endlink and the message to be
/// logged at this log level (as a standard `NULL`-terminated `const char[]`).
///
/// You should prefer using the log level specific macros error(), warning(),
/// info(), debug() and trace() over this one, outside of special circumstances
/// where you want to dynamically adjust the log level at runtime.
///
/// If generating a message requires expensive processing that should not be
/// performed when the target log level is disabled, you should use
/// log_enabled() to test ahead of time whether this log level is enabled.
///
/// See also log_with_errno() when reporting a failure from system calls and
/// third-party C libraries..
#define log(level, message)  \
    do {  \
        const udipe_log_level_t udipe_level = (level);  \
        if (log_enabled(udipe_level)) {  \
            (udipe_thread_logger->callback)(udipe_thread_logger->context,  \
                                            udipe_level,  \
                                            __func__,  \
                                            (message));  \
        }  \
    } while(false)

/// Log a \link #UDIPE_LOG_TRACE `TRACE` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define trace(message)  log(UDIPE_LOG_TRACE, (message))

/// Log a \link #UDIPE_LOG_DEBUG `DEBUG` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define debug(message)  log(UDIPE_LOG_DEBUG, (message))

/// Log an \link #UDIPE_LOG_INFO `INFO` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define info(message)  log(UDIPE_LOG_INFO, (message))

/// Log a \link #UDIPE_LOG_WARNING `WARNING` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define warning(message)  log(UDIPE_LOG_WARNING, (message))

/// Log an \link #UDIPE_LOG_ERROR `ERROR` \endlink message
///
/// Can only be used within the scope of with_logger(). See log() for more info.
#define error(message)  log(UDIPE_LOG_ERROR, (message))

///@}


/// \name Thread-local logger
///@{

/// Thread-local logger (implementation detail of with_logger())
///
/// This thread-local variable is used by with_logger() in order to locally
/// enable a lightweight log syntax. It should not be used by any code other
/// than the log() and with_logger() macro.
extern thread_local const logger_t* udipe_thread_logger;

/// Restore `udipe_thread_logger` (implementation detail of with_logger())
///
/// This helper function enables with_logger() to clean up after itself through
/// the GNU `__cleanup__` attribute.
static inline void restore_thread_logger(const logger_t** prev_logger) {
    trace("End of a with_logger() scope");
    udipe_thread_logger = *prev_logger;
}

/// Set up logging within a certain code scope
///
/// Call as `with_logger(&logger, { ... })` to be able to use log() and related
/// macros inside of the ... inner code scope.
///
/// This macro is meant to be called at the start of every public `libudipe`
/// entry point and also early in the main function of every udipe worker
/// thread.
///
/// \param logger_ptr must point to a `logger_t` that was previously initialized
///        by log_initialize(), and that is valid to use until the end of the
///        code scope delimited by the with_logger() macro.
#define with_logger(logger_ptr, ...)  \
    do {  \
        const logger_t* udipe_prev_logger  \
                        __attribute__((__cleanup__(restore_thread_logger)))  \
                        = udipe_thread_logger;  \
        udipe_thread_logger = (logger_ptr);  \
        trace("Start of a with_logger() scope");  \
        do __VA_ARGS__ while(false);  \
    } while(false)

///@}


/// \name Logging utilities
///@{

/// Internal helper to validate logging call correctness in `Debug` builds
#ifndef NDEBUG
    void validate_log(udipe_log_level_t level);
#else
    static inline void validate_log(udipe_log_level_t level) {}
#endif

///@}


// Implementation of log_enabled (see above for docs)
static inline bool log_enabled(udipe_log_level_t level) {
    validate_log(level);
    return level >= udipe_thread_logger->min_level;
}
